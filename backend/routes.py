"""
API routes for Qode.
Defines all HTTP endpoints for queue and ticket management.
"""
from fastapi import APIRouter, Depends, HTTPException, Header, WebSocket, WebSocketDisconnect
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, List

from database import get_db
from schemas import (
    QueueCreate,
    QueueResponse,
    QueuePublicResponse,
    TicketResponse,
    ErrorResponse
)
from services import queue_service, ticket_service
from manager import manager


# Initialize router
router = APIRouter()


# ============================================================================
# Queue Endpoints
# ============================================================================

@router.post("/queues", response_model=QueueResponse, status_code=201)
async def create_queue(
    queue_data: QueueCreate,
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new queue.

    Returns the full queue object INCLUDING the secret host_token.
    The frontend must save this token in localStorage.

    Args:
        queue_data: Queue creation data (name)
        db: Database session

    Returns:
        QueueResponse with host_token
    """
    try:
        queue = await queue_service.create_new_queue(db, queue_data.name)
        return QueueResponse.model_validate(queue)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to create queue")


@router.get("/queues/{queue_id}", response_model=QueuePublicResponse)
async def get_queue(
    queue_id: str,
    x_host_token: Optional[str] = Header(None),
    db: AsyncSession = Depends(get_db)
):
    """
    Get queue information.

    This is a PROTECTED endpoint if x-host-token is provided.
    Public access returns limited info.

    Args:
        queue_id: Queue UUID
        x_host_token: Optional host authentication token
        db: Database session

    Returns:
        QueuePublicResponse (without host_token)
    """
    try:
        # Verify queue exists
        queue = await queue_service.get_queue_by_id(db, queue_id)

        # If host token provided, validate it
        if x_host_token:
            is_valid = await queue_service.verify_host_token(
                db, queue_id, x_host_token
            )
            if not is_valid:
                raise HTTPException(status_code=403, detail="Invalid host token")

        return QueuePublicResponse.model_validate(queue)

    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to retrieve queue")


# ============================================================================
# Ticket Endpoints
# ============================================================================

@router.post("/queues/{queue_id}/join", response_model=TicketResponse, status_code=201)
async def join_queue(
    queue_id: str,
    x_device_token: str = Header(..., description="Anonymous device identifier (UUID)"),
    db: AsyncSession = Depends(get_db)
):
    """
    Join a queue and receive a ticket.

    CRITICAL: This endpoint implements atomic ticket creation to prevent
    race conditions when multiple users join simultaneously.

    The x-device-token header is a UUID generated by the frontend and
    stored in localStorage. It identifies the user anonymously.

    Idempotency: If the device already has an active ticket in this queue,
    the existing ticket is returned instead of creating a duplicate.

    Args:
        queue_id: Queue UUID
        x_device_token: Anonymous device identifier from header
        db: Database session

    Returns:
        TicketResponse with position number and status
    """
    try:
        ticket = await ticket_service.join_queue(
            db=db,
            queue_id=queue_id,
            device_token=x_device_token
        )
        return TicketResponse.model_validate(ticket)

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        print(f"Error joining queue: {e}")
        raise HTTPException(status_code=500, detail="Failed to join queue")


@router.get("/queues/{queue_id}/tickets", response_model=List[TicketResponse])
async def get_queue_tickets(
    queue_id: str,
    x_host_token: str = Header(..., description="Host authentication token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Get all WAITING tickets for a queue (Host only).

    Requires valid host token for authentication.

    Args:
        queue_id: Queue UUID
        x_host_token: Host authentication token
        db: Database session

    Returns:
        List of TicketResponse objects (WAITING status only)
    """
    try:
        # Verify host token
        is_valid = await queue_service.verify_host_token(db, queue_id, x_host_token)
        if not is_valid:
            raise HTTPException(status_code=403, detail="Invalid host token")

        # Get all WAITING tickets
        from crud import tickets as ticket_crud
        from models import TicketStatus
        from sqlalchemy import select

        result = await db.execute(
            select(ticket_crud.Ticket)
            .where(
                ticket_crud.Ticket.queue_id == queue_id,
                ticket_crud.Ticket.status == TicketStatus.WAITING
            )
            .order_by(ticket_crud.Ticket.position_number)
        )
        tickets = result.scalars().all()

        return [TicketResponse.model_validate(ticket) for ticket in tickets]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching tickets: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch tickets")


@router.post("/tickets/{ticket_id}/verify")
async def verify_ticket(
    ticket_id: str,
    x_host_token: str = Header(..., description="Host authentication token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Verify/complete a ticket (Host Action).

    CRITICAL: This endpoint:
    1. Validates host authentication
    2. Transitions ticket WAITING -> COMPLETED
    3. Updates queue current_position
    4. Calculates new ETA using Exponential Moving Average
    5. Broadcasts update to all WebSocket clients

    Args:
        ticket_id: Ticket UUID to verify
        x_host_token: Host authentication token
        db: Database session

    Returns:
        Success message with broadcast data
    """
    try:
        # First, get the ticket to find its queue_id
        ticket = await ticket_service.get_ticket(db, ticket_id)
        queue_id = ticket.queue_id

        # Verify host token
        is_valid = await queue_service.verify_host_token(db, queue_id, x_host_token)
        if not is_valid:
            raise HTTPException(status_code=403, detail="Invalid host token")

        # Verify ticket and get broadcast data
        broadcast_data = await ticket_service.verify_ticket(db, ticket_id, queue_id)

        # Broadcast to all WebSocket clients in this queue
        await manager.broadcast(queue_id, broadcast_data)

        return {
            "status": "success",
            "message": f"Ticket {ticket_id} verified",
            "broadcast": broadcast_data
        }

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error verifying ticket: {e}")
        raise HTTPException(status_code=500, detail="Failed to verify ticket")


@router.post("/tickets/{ticket_id}/noshow")
async def mark_ticket_no_show(
    ticket_id: str,
    x_host_token: str = Header(..., description="Host authentication token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Mark a ticket as NO_SHOW (Host Action).

    Unlike verify, this does NOT advance current_position.
    It simply marks the ticket as a no-show and removes it from the waiting list.

    Args:
        ticket_id: Ticket UUID to mark as no-show
        x_host_token: Host authentication token
        db: Database session

    Returns:
        Success message
    """
    try:
        # First, get the ticket to find its queue_id
        ticket = await ticket_service.get_ticket(db, ticket_id)
        queue_id = ticket.queue_id

        # Verify host token
        is_valid = await queue_service.verify_host_token(db, queue_id, x_host_token)
        if not is_valid:
            raise HTTPException(status_code=403, detail="Invalid host token")

        # Mark as no-show
        broadcast_data = await ticket_service.mark_no_show(db, ticket_id, queue_id)

        # Broadcast to WebSocket clients
        await manager.broadcast(queue_id, broadcast_data)

        return {
            "status": "success",
            "message": f"Ticket {ticket_id} marked as no-show"
        }

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error marking no-show: {e}")
        raise HTTPException(status_code=500, detail="Failed to mark ticket as no-show")


# ============================================================================
# WebSocket Endpoint
# ============================================================================

@router.websocket("/ws/{queue_id}")
async def websocket_endpoint(websocket: WebSocket, queue_id: str):
    """
    WebSocket endpoint for real-time queue updates.

    Clients connect to receive live updates about:
    - Current position being served
    - Updated average wait time
    - Queue status changes

    Args:
        websocket: WebSocket connection
        queue_id: Queue UUID to subscribe to
    """
    await manager.connect(queue_id, websocket)

    try:
        # Keep connection alive and listen for messages
        while True:
            # Wait for any message from client (ping/pong to keep alive)
            data = await websocket.receive_text()
            # Echo back for debugging (optional)
            # await websocket.send_text(f"Message received: {data}")

    except WebSocketDisconnect:
        manager.disconnect(queue_id, websocket)
        print(f"[WS] Client disconnected from queue {queue_id}")
